
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>postgres: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/francknouama/movies-mcp-server/mcp-server/internal/infrastructure/postgres/actor_repository.go (80.1%)</option>
				
				<option value="file1">github.com/francknouama/movies-mcp-server/mcp-server/internal/infrastructure/postgres/movie_repository.go (74.4%)</option>
				
				<option value="file2">github.com/francknouama/movies-mcp-server/mcp-server/internal/infrastructure/postgres/testcontainers_setup.go (37.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/francknouama/movies-mcp-server/mcp-server/internal/domain/actor"
        "github.com/francknouama/movies-mcp-server/mcp-server/internal/domain/shared"
        "github.com/francknouama/movies-mcp-server/shared-mcp/pkg/database"
)

// ActorRepository implements the actor.Repository interface for PostgreSQL
type ActorRepository struct {
        *database.BaseRepository
        txManager *database.TransactionManager
}

// NewActorRepository creates a new PostgreSQL actor repository
func NewActorRepository(db *sql.DB) *ActorRepository <span class="cov8" title="1">{
        return &amp;ActorRepository{
                BaseRepository: database.NewBaseRepository(db),
                txManager:      database.NewTransactionManager(db),
        }
}</span>

// dbActor represents the database model for actors
type dbActor struct {
        ID        int            `db:"id"`
        Name      string         `db:"name"`
        BirthYear sql.NullInt64  `db:"birth_year"`
        Bio       sql.NullString `db:"bio"`
        CreatedAt sql.NullTime   `db:"created_at"`
        UpdatedAt sql.NullTime   `db:"updated_at"`
}

// Save persists an actor (insert or update)
func (r *ActorRepository) Save(ctx context.Context, domainActor *actor.Actor) error <span class="cov8" title="1">{
        dbActor := r.toDBModel(domainActor)

        if domainActor.ID().IsZero() </span><span class="cov8" title="1">{
                return r.insert(ctx, dbActor, domainActor)
        }</span>
        <span class="cov8" title="1">return r.update(ctx, dbActor, domainActor)</span>
}

func (r *ActorRepository) insert(ctx context.Context, dbActor *dbActor, domainActor *actor.Actor) error <span class="cov8" title="1">{
        return r.txManager.WithTransaction(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                helper := database.NewTransactionHelper(tx)

                // Insert actor
                query := `
                        INSERT INTO actors (name, birth_year, bio, created_at, updated_at)
                        VALUES ($1, $2, $3, $4, $5)
                        RETURNING id`

                id, err := helper.InsertWithID(ctx, query,
                        dbActor.Name,
                        dbActor.BirthYear,
                        dbActor.Bio,
                        dbActor.CreatedAt.Time,
                        dbActor.UpdatedAt.Time,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert actor: %w", err)
                }</span>

                // Update domain actor with the new ID
                <span class="cov8" title="1">actorID, err := shared.NewActorID(id)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create actor ID: %w", err)
                }</span>
                <span class="cov8" title="1">domainActor.SetID(actorID)

                // Insert movie relationships
                if err := r.insertMovieRelationships(ctx, tx, domainActor); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert movie relationships: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
}

func (r *ActorRepository) update(ctx context.Context, dbActor *dbActor, domainActor *actor.Actor) error <span class="cov8" title="1">{
        return r.txManager.WithTransaction(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                helper := database.NewTransactionHelper(tx)

                // Update actor
                query := `
                        UPDATE actors 
                        SET name = $2, birth_year = $3, bio = $4, updated_at = $5
                        WHERE id = $1`

                err := helper.Update(ctx, query, "actor",
                        domainActor.ID().Value(),
                        dbActor.Name,
                        dbActor.BirthYear,
                        dbActor.Bio,
                        dbActor.UpdatedAt.Time,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Update movie relationships
                <span class="cov8" title="1">if err := r.updateMovieRelationships(ctx, tx, domainActor); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update movie relationships: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
}

func (r *ActorRepository) insertMovieRelationships(ctx context.Context, tx *sql.Tx, domainActor *actor.Actor) error <span class="cov8" title="1">{
        for _, movieID := range domainActor.MovieIDs() </span><span class="cov8" title="1">{
                query := `
                        INSERT INTO movie_actors (movie_id, actor_id, created_at)
                        VALUES ($1, $2, CURRENT_TIMESTAMP)
                        ON CONFLICT (movie_id, actor_id) DO NOTHING`

                _, err := tx.ExecContext(ctx, query, movieID.Value(), domainActor.ID().Value())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert movie relationship: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *ActorRepository) updateMovieRelationships(ctx context.Context, tx *sql.Tx, domainActor *actor.Actor) error <span class="cov8" title="1">{
        // Delete existing relationships
        deleteQuery := "DELETE FROM movie_actors WHERE actor_id = $1"
        _, err := tx.ExecContext(ctx, deleteQuery, domainActor.ID().Value())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete existing movie relationships: %w", err)
        }</span>

        // Insert new relationships
        <span class="cov8" title="1">return r.insertMovieRelationships(ctx, tx, domainActor)</span>
}

// FindByID retrieves an actor by their ID
func (r *ActorRepository) FindByID(ctx context.Context, id shared.ActorID) (*actor.Actor, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, birth_year, bio, created_at, updated_at
                FROM actors 
                WHERE id = $1`

        var dbActor dbActor
        err := r.QueryRowContext(ctx, query, id.Value()).Scan(
                &amp;dbActor.ID,
                &amp;dbActor.Name,
                &amp;dbActor.BirthYear,
                &amp;dbActor.Bio,
                &amp;dbActor.CreatedAt,
                &amp;dbActor.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                return nil, r.WrapNotFound(err, "actor")
        }</span>

        // Get movie relationships
        <span class="cov8" title="1">movieIDs, err := r.getActorMovieIDs(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get actor movie IDs: %w", err)
        }</span>

        <span class="cov8" title="1">return r.toDomainModel(&amp;dbActor, movieIDs)</span>
}

func (r *ActorRepository) getActorMovieIDs(ctx context.Context, actorID shared.ActorID) ([]shared.MovieID, error) <span class="cov8" title="1">{
        query := "SELECT movie_id FROM movie_actors WHERE actor_id = $1"
        rows, err := r.QueryContext(ctx, query, actorID.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query movie relationships: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var movieIDs []shared.MovieID
        for rows.Next() </span><span class="cov8" title="1">{
                var movieIDValue int
                if err := rows.Scan(&amp;movieIDValue); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan movie ID: %w", err)
                }</span>

                <span class="cov8" title="1">movieID, err := shared.NewMovieID(movieIDValue)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create movie ID: %w", err)
                }</span>

                <span class="cov8" title="1">movieIDs = append(movieIDs, movieID)</span>
        }

        <span class="cov8" title="1">return movieIDs, nil</span>
}

// FindByCriteria retrieves actors based on search criteria
func (r *ActorRepository) FindByCriteria(ctx context.Context, criteria actor.SearchCriteria) ([]*actor.Actor, error) <span class="cov8" title="1">{
        query, args := r.buildSearchQuery(criteria)

        rows, err := r.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search actors: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var actors []*actor.Actor
        for rows.Next() </span><span class="cov8" title="1">{
                var dbActor dbActor
                err := rows.Scan(
                        &amp;dbActor.ID,
                        &amp;dbActor.Name,
                        &amp;dbActor.BirthYear,
                        &amp;dbActor.Bio,
                        &amp;dbActor.CreatedAt,
                        &amp;dbActor.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan actor: %w", err)
                }</span>

                <span class="cov8" title="1">actorID, err := shared.NewActorID(dbActor.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create actor ID: %w", err)
                }</span>

                // Get movie relationships
                <span class="cov8" title="1">movieIDs, err := r.getActorMovieIDs(ctx, actorID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get actor movie IDs: %w", err)
                }</span>

                <span class="cov8" title="1">domainActor, err := r.toDomainModel(&amp;dbActor, movieIDs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert to domain model: %w", err)
                }</span>

                <span class="cov8" title="1">actors = append(actors, domainActor)</span>
        }

        <span class="cov8" title="1">return actors, nil</span>
}

func (r *ActorRepository) buildSearchQuery(criteria actor.SearchCriteria) (string, []interface{}) <span class="cov8" title="1">{
        query := `
                SELECT DISTINCT a.id, a.name, a.birth_year, a.bio, a.created_at, a.updated_at
                FROM actors a`

        var args []interface{}
        argIndex := 1
        var conditions []string

        // Join with movie_actors if searching by movie
        if !criteria.MovieID.IsZero() </span><span class="cov8" title="1">{
                query += " INNER JOIN movie_actors ma ON a.id = ma.actor_id"
                conditions = append(conditions, fmt.Sprintf("ma.movie_id = $%d", argIndex))
                args = append(args, criteria.MovieID.Value())
                argIndex++
        }</span>

        // Add WHERE conditions
        <span class="cov8" title="1">if criteria.Name != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, fmt.Sprintf("a.name ILIKE $%d", argIndex))
                args = append(args, "%"+criteria.Name+"%")
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.MinBirthYear &gt; 0 </span><span class="cov8" title="1">{
                conditions = append(conditions, fmt.Sprintf("a.birth_year &gt;= $%d", argIndex))
                args = append(args, criteria.MinBirthYear)
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.MaxBirthYear &gt; 0 </span><span class="cov8" title="1">{
                conditions = append(conditions, fmt.Sprintf("a.birth_year &lt;= $%d", argIndex))
                args = append(args, criteria.MaxBirthYear)
                argIndex++
        }</span>

        <span class="cov8" title="1">if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                query += " WHERE " + conditions[0]
                for i := 1; i &lt; len(conditions); i++ </span><span class="cov8" title="1">{
                        query += " AND " + conditions[i]
                }</span>
        }

        // Add ORDER BY
        <span class="cov8" title="1">orderField := "a.name"
        switch criteria.OrderBy </span>{
        case actor.OrderByBirthYear:<span class="cov8" title="1">
                orderField = "a.birth_year"</span>
        case actor.OrderByCreatedAt:<span class="cov0" title="0">
                orderField = "a.created_at"</span>
        case actor.OrderByUpdatedAt:<span class="cov0" title="0">
                orderField = "a.updated_at"</span>
        }

        <span class="cov8" title="1">orderDir := "ASC"
        if criteria.OrderDir == actor.OrderDesc </span><span class="cov8" title="1">{
                orderDir = "DESC"
        }</span>

        <span class="cov8" title="1">query += fmt.Sprintf(" ORDER BY %s %s", orderField, orderDir)

        // Add LIMIT and OFFSET
        if criteria.Limit &gt; 0 </span><span class="cov8" title="1">{
                query += fmt.Sprintf(" LIMIT $%d", argIndex)
                args = append(args, criteria.Limit)
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.Offset &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" OFFSET $%d", argIndex)
                args = append(args, criteria.Offset)
        }</span>

        <span class="cov8" title="1">return query, args</span>
}

// FindByName searches actors by name (partial match)
func (r *ActorRepository) FindByName(ctx context.Context, name string) ([]*actor.Actor, error) <span class="cov0" title="0">{
        criteria := actor.SearchCriteria{
                Name:  name,
                Limit: 100, // Default limit
        }
        return r.FindByCriteria(ctx, criteria)
}</span>

// FindByMovieID retrieves actors who appeared in a specific movie
func (r *ActorRepository) FindByMovieID(ctx context.Context, movieID shared.MovieID) ([]*actor.Actor, error) <span class="cov8" title="1">{
        criteria := actor.SearchCriteria{
                MovieID: movieID,
                Limit:   100, // Default limit
        }
        return r.FindByCriteria(ctx, criteria)
}</span>

// CountAll returns the total number of actors
func (r *ActorRepository) CountAll(ctx context.Context) (int, error) <span class="cov8" title="1">{
        query := "SELECT COUNT(*) FROM actors"
        return r.Count(ctx, query)
}</span>

// Delete removes an actor by ID
func (r *ActorRepository) Delete(ctx context.Context, id shared.ActorID) error <span class="cov8" title="1">{
        return r.txManager.WithTransaction(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                helper := database.NewTransactionHelper(tx)

                // Delete movie relationships first (foreign key constraints)
                deleteRelQuery := "DELETE FROM movie_actors WHERE actor_id = $1"
                _, err := tx.ExecContext(ctx, deleteRelQuery, id.Value())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete actor movie relationships: %w", err)
                }</span>

                // Delete actor
                <span class="cov8" title="1">deleteQuery := "DELETE FROM actors WHERE id = $1"
                return helper.Delete(ctx, deleteQuery, "actor", id.Value())</span>
        })
}

// DeleteAll removes all actors (for testing)
func (r *ActorRepository) DeleteAll(ctx context.Context) error <span class="cov0" title="0">{
        return r.txManager.WithTransaction(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                // Delete all movie relationships first
                _, err := tx.ExecContext(ctx, "DELETE FROM movie_actors")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete all movie relationships: %w", err)
                }</span>

                // Delete all actors
                <span class="cov0" title="0">_, err = tx.ExecContext(ctx, "DELETE FROM actors")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete all actors: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

// toDBModel converts a domain actor to a database model
func (r *ActorRepository) toDBModel(domainActor *actor.Actor) *dbActor <span class="cov8" title="1">{
        dbActor := &amp;dbActor{
                ID:   domainActor.ID().Value(),
                Name: domainActor.Name(),
        }

        // Handle optional birth year
        if !domainActor.BirthYear().IsZero() </span><span class="cov8" title="1">{
                dbActor.BirthYear = sql.NullInt64{
                        Int64: int64(domainActor.BirthYear().Value()),
                        Valid: true,
                }
        }</span>

        // Handle optional bio
        <span class="cov8" title="1">if domainActor.Bio() != "" </span><span class="cov8" title="1">{
                dbActor.Bio = sql.NullString{
                        String: domainActor.Bio(),
                        Valid:  true,
                }
        }</span>

        // Handle timestamps
        <span class="cov8" title="1">dbActor.CreatedAt = sql.NullTime{
                Time:  domainActor.CreatedAt(),
                Valid: true,
        }
        dbActor.UpdatedAt = sql.NullTime{
                Time:  domainActor.UpdatedAt(),
                Valid: true,
        }

        return dbActor</span>
}

// toDomainModel converts a database model to a domain actor
func (r *ActorRepository) toDomainModel(dbActor *dbActor, movieIDs []shared.MovieID) (*actor.Actor, error) <span class="cov8" title="1">{
        actorID, err := shared.NewActorID(dbActor.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid actor ID: %w", err)
        }</span>

        <span class="cov8" title="1">birthYear := 1900 // Default if not set
        if dbActor.BirthYear.Valid </span><span class="cov8" title="1">{
                birthYear = int(dbActor.BirthYear.Int64)
        }</span>

        <span class="cov8" title="1">domainActor, err := actor.NewActorWithID(actorID, dbActor.Name, birthYear)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create domain actor: %w", err)
        }</span>

        // Set bio if present
        <span class="cov8" title="1">if dbActor.Bio.Valid </span><span class="cov8" title="1">{
                domainActor.SetBio(dbActor.Bio.String)
        }</span>

        // Add movie relationships
        <span class="cov8" title="1">for _, movieID := range movieIDs </span><span class="cov8" title="1">{
                if err := domainActor.AddMovie(movieID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add movie to actor: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return domainActor, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/lib/pq"

        "github.com/francknouama/movies-mcp-server/mcp-server/internal/domain/movie"
        "github.com/francknouama/movies-mcp-server/mcp-server/internal/domain/shared"
        "github.com/francknouama/movies-mcp-server/shared-mcp/pkg/database"
)

// MovieRepository implements the movie.Repository interface for PostgreSQL
type MovieRepository struct {
        *database.BaseRepository
}

// NewMovieRepository creates a new PostgreSQL movie repository
func NewMovieRepository(db *sql.DB) *MovieRepository <span class="cov8" title="1">{
        return &amp;MovieRepository{
                BaseRepository: database.NewBaseRepository(db),
        }
}</span>

// dbMovie represents the database model for movies
type dbMovie struct {
        ID          int             `db:"id"`
        Title       string          `db:"title"`
        Director    string          `db:"director"`
        Year        int             `db:"year"`
        Rating      sql.NullFloat64 `db:"rating"`
        Genres      pq.StringArray  `db:"genre"`
        Description sql.NullString  `db:"description"`
        Duration    sql.NullInt64   `db:"duration"`
        Language    sql.NullString  `db:"language"`
        Country     sql.NullString  `db:"country"`
        PosterData  []byte          `db:"poster_data"`
        PosterType  sql.NullString  `db:"poster_type"`
        PosterURL   sql.NullString  `db:"poster_url"`
        CreatedAt   sql.NullTime    `db:"created_at"`
        UpdatedAt   sql.NullTime    `db:"updated_at"`
}

// Save persists a movie (insert or update)
func (r *MovieRepository) Save(ctx context.Context, domainMovie *movie.Movie) error <span class="cov8" title="1">{
        dbMovie := r.toDBModel(domainMovie)

        if domainMovie.ID().IsZero() </span><span class="cov8" title="1">{
                return r.insert(ctx, dbMovie, domainMovie)
        }</span>
        <span class="cov8" title="1">return r.update(ctx, dbMovie, domainMovie)</span>
}

func (r *MovieRepository) insert(ctx context.Context, dbMovie *dbMovie, domainMovie *movie.Movie) error <span class="cov8" title="1">{
        query := `
                INSERT INTO movies (title, director, year, rating, genre, poster_url, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING id`

        id, err := r.InsertWithID(ctx, query,
                dbMovie.Title,
                dbMovie.Director,
                dbMovie.Year,
                dbMovie.Rating,
                dbMovie.Genres,
                dbMovie.PosterURL,
                dbMovie.CreatedAt.Time,
                dbMovie.UpdatedAt.Time,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert movie: %w", err)
        }</span>

        // Update domain movie with the new ID
        <span class="cov8" title="1">movieID, err := shared.NewMovieID(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create movie ID: %w", err)
        }</span>
        <span class="cov8" title="1">domainMovie.SetID(movieID)

        return nil</span>
}

func (r *MovieRepository) update(ctx context.Context, dbMovie *dbMovie, domainMovie *movie.Movie) error <span class="cov8" title="1">{
        query := `
                UPDATE movies 
                SET title = $2, director = $3, year = $4, rating = $5, genre = $6, 
                    poster_url = $7, updated_at = $8
                WHERE id = $1`

        return r.Update(ctx, query, "movie",
                domainMovie.ID().Value(),
                dbMovie.Title,
                dbMovie.Director,
                dbMovie.Year,
                dbMovie.Rating,
                dbMovie.Genres,
                dbMovie.PosterURL,
                dbMovie.UpdatedAt.Time,
        )
}</span>

// FindByID retrieves a movie by its ID
func (r *MovieRepository) FindByID(ctx context.Context, id shared.MovieID) (*movie.Movie, error) <span class="cov8" title="1">{
        query := `
                SELECT id, title, director, year, rating, genre, poster_url, created_at, updated_at
                FROM movies 
                WHERE id = $1`

        var dbMovie dbMovie
        err := r.QueryRowContext(ctx, query, id.Value()).Scan(
                &amp;dbMovie.ID,
                &amp;dbMovie.Title,
                &amp;dbMovie.Director,
                &amp;dbMovie.Year,
                &amp;dbMovie.Rating,
                &amp;dbMovie.Genres,
                &amp;dbMovie.PosterURL,
                &amp;dbMovie.CreatedAt,
                &amp;dbMovie.UpdatedAt,
        )

        if err != nil </span><span class="cov8" title="1">{
                return nil, r.WrapNotFound(err, "movie")
        }</span>

        <span class="cov8" title="1">return r.toDomainModel(&amp;dbMovie)</span>
}

// FindByCriteria retrieves movies based on search criteria
func (r *MovieRepository) FindByCriteria(ctx context.Context, criteria movie.SearchCriteria) ([]*movie.Movie, error) <span class="cov8" title="1">{
        query, args := r.buildSearchQuery(criteria)

        rows, err := r.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search movies: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var movies []*movie.Movie
        for rows.Next() </span><span class="cov8" title="1">{
                var dbMovie dbMovie
                err := rows.Scan(
                        &amp;dbMovie.ID,
                        &amp;dbMovie.Title,
                        &amp;dbMovie.Director,
                        &amp;dbMovie.Year,
                        &amp;dbMovie.Rating,
                        &amp;dbMovie.Genres,
                        &amp;dbMovie.PosterURL,
                        &amp;dbMovie.CreatedAt,
                        &amp;dbMovie.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan movie: %w", err)
                }</span>

                <span class="cov8" title="1">domainMovie, err := r.toDomainModel(&amp;dbMovie)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert to domain model: %w", err)
                }</span>

                <span class="cov8" title="1">movies = append(movies, domainMovie)</span>
        }

        <span class="cov8" title="1">return movies, nil</span>
}

func (r *MovieRepository) buildSearchQuery(criteria movie.SearchCriteria) (string, []interface{}) <span class="cov8" title="1">{
        query := `
                SELECT id, title, director, year, rating, genre, poster_url, created_at, updated_at
                FROM movies WHERE 1=1`

        var args []interface{}
        argIndex := 1

        // Add WHERE conditions
        if criteria.Title != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND title ILIKE $%d", argIndex)
                args = append(args, "%"+criteria.Title+"%")
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.Director != "" </span><span class="cov8" title="1">{
                query += fmt.Sprintf(" AND director ILIKE $%d", argIndex)
                args = append(args, "%"+criteria.Director+"%")
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.Genre != "" </span><span class="cov8" title="1">{
                query += fmt.Sprintf(" AND $%d = ANY(genre)", argIndex)
                args = append(args, criteria.Genre)
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.MinYear &gt; 0 </span><span class="cov8" title="1">{
                query += fmt.Sprintf(" AND year &gt;= $%d", argIndex)
                args = append(args, criteria.MinYear)
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.MaxYear &gt; 0 </span><span class="cov8" title="1">{
                query += fmt.Sprintf(" AND year &lt;= $%d", argIndex)
                args = append(args, criteria.MaxYear)
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.MinRating &gt; 0 </span><span class="cov8" title="1">{
                query += fmt.Sprintf(" AND rating &gt;= $%d", argIndex)
                args = append(args, criteria.MinRating)
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.MaxRating &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND rating &lt;= $%d", argIndex)
                args = append(args, criteria.MaxRating)
                argIndex++
        }</span>

        // Add ORDER BY
        <span class="cov8" title="1">orderField := "title"
        switch criteria.OrderBy </span>{
        case movie.OrderByDirector:<span class="cov0" title="0">
                orderField = "director"</span>
        case movie.OrderByYear:<span class="cov0" title="0">
                orderField = "year"</span>
        case movie.OrderByRating:<span class="cov8" title="1">
                orderField = "rating"</span>
        case movie.OrderByCreatedAt:<span class="cov0" title="0">
                orderField = "created_at"</span>
        case movie.OrderByUpdatedAt:<span class="cov0" title="0">
                orderField = "updated_at"</span>
        }

        <span class="cov8" title="1">orderDir := "ASC"
        if criteria.OrderDir == movie.OrderDesc </span><span class="cov8" title="1">{
                orderDir = "DESC"
        }</span>

        <span class="cov8" title="1">query += fmt.Sprintf(" ORDER BY %s %s", orderField, orderDir)

        // Add LIMIT and OFFSET
        if criteria.Limit &gt; 0 </span><span class="cov8" title="1">{
                query += fmt.Sprintf(" LIMIT $%d", argIndex)
                args = append(args, criteria.Limit)
                argIndex++
        }</span>

        <span class="cov8" title="1">if criteria.Offset &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" OFFSET $%d", argIndex)
                args = append(args, criteria.Offset)
        }</span>

        <span class="cov8" title="1">return query, args</span>
}

// FindByTitle searches movies by title (partial match)
func (r *MovieRepository) FindByTitle(ctx context.Context, title string) ([]*movie.Movie, error) <span class="cov0" title="0">{
        criteria := movie.SearchCriteria{
                Title: title,
                Limit: 100, // Default limit
        }
        return r.FindByCriteria(ctx, criteria)
}</span>

// FindByDirector retrieves movies by director
func (r *MovieRepository) FindByDirector(ctx context.Context, director string) ([]*movie.Movie, error) <span class="cov0" title="0">{
        criteria := movie.SearchCriteria{
                Director: director,
                Limit:    100, // Default limit
        }
        return r.FindByCriteria(ctx, criteria)
}</span>

// FindByGenre retrieves movies that have a specific genre
func (r *MovieRepository) FindByGenre(ctx context.Context, genre string) ([]*movie.Movie, error) <span class="cov0" title="0">{
        criteria := movie.SearchCriteria{
                Genre: genre,
                Limit: 100, // Default limit
        }
        return r.FindByCriteria(ctx, criteria)
}</span>

// FindTopRated retrieves top-rated movies
func (r *MovieRepository) FindTopRated(ctx context.Context, limit int) ([]*movie.Movie, error) <span class="cov8" title="1">{
        criteria := movie.SearchCriteria{
                OrderBy:   movie.OrderByRating,
                OrderDir:  movie.OrderDesc,
                Limit:     limit,
                MinRating: 0.1, // Only movies with ratings
        }
        return r.FindByCriteria(ctx, criteria)
}</span>

// CountAll returns the total number of movies
func (r *MovieRepository) CountAll(ctx context.Context) (int, error) <span class="cov8" title="1">{
        query := "SELECT COUNT(*) FROM movies"
        return r.Count(ctx, query)
}</span>

// Delete removes a movie by ID
func (r *MovieRepository) Delete(ctx context.Context, id shared.MovieID) error <span class="cov8" title="1">{
        query := "DELETE FROM movies WHERE id = $1"
        return r.BaseRepository.Delete(ctx, query, "movie", id.Value())
}</span>

// DeleteAll removes all movies (for testing)
func (r *MovieRepository) DeleteAll(ctx context.Context) error <span class="cov0" title="0">{
        query := "DELETE FROM movies"
        _, err := r.ExecContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete all movies: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// toDBModel converts a domain movie to a database model
func (r *MovieRepository) toDBModel(domainMovie *movie.Movie) *dbMovie <span class="cov8" title="1">{
        dbMovie := &amp;dbMovie{
                ID:       domainMovie.ID().Value(),
                Title:    domainMovie.Title(),
                Director: domainMovie.Director(),
                Year:     domainMovie.Year().Value(),
                Genres:   pq.StringArray(domainMovie.Genres()),
        }

        // Handle optional rating
        if !domainMovie.Rating().IsZero() </span><span class="cov8" title="1">{
                dbMovie.Rating = sql.NullFloat64{
                        Float64: domainMovie.Rating().Value(),
                        Valid:   true,
                }
        }</span>

        // Handle optional poster URL
        <span class="cov8" title="1">if domainMovie.PosterURL() != "" </span><span class="cov8" title="1">{
                dbMovie.PosterURL = sql.NullString{
                        String: domainMovie.PosterURL(),
                        Valid:  true,
                }
        }</span>

        // Handle timestamps
        <span class="cov8" title="1">dbMovie.CreatedAt = sql.NullTime{
                Time:  domainMovie.CreatedAt(),
                Valid: true,
        }
        dbMovie.UpdatedAt = sql.NullTime{
                Time:  domainMovie.UpdatedAt(),
                Valid: true,
        }

        return dbMovie</span>
}

// toDomainModel converts a database model to a domain movie
func (r *MovieRepository) toDomainModel(dbMovie *dbMovie) (*movie.Movie, error) <span class="cov8" title="1">{
        movieID, err := shared.NewMovieID(dbMovie.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid movie ID: %w", err)
        }</span>

        <span class="cov8" title="1">domainMovie, err := movie.NewMovieWithID(movieID, dbMovie.Title, dbMovie.Director, dbMovie.Year)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create domain movie: %w", err)
        }</span>

        // Set rating if present
        <span class="cov8" title="1">if dbMovie.Rating.Valid </span><span class="cov8" title="1">{
                if err := domainMovie.SetRating(dbMovie.Rating.Float64); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set rating: %w", err)
                }</span>
        }

        // Add genres
        <span class="cov8" title="1">for _, genre := range dbMovie.Genres </span><span class="cov8" title="1">{
                if err := domainMovie.AddGenre(genre); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add genre: %w", err)
                }</span>
        }

        // Set poster URL if present
        <span class="cov8" title="1">if dbMovie.PosterURL.Valid </span><span class="cov8" title="1">{
                if err := domainMovie.SetPosterURL(dbMovie.PosterURL.String); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set poster URL: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return domainMovie, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">//go:build integration
// +build integration

package postgres

import (
        "context"
        "database/sql"
        "fmt"
        "path/filepath"
        "testing"
        "time"

        _ "github.com/lib/pq"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/modules/postgres"
        "github.com/testcontainers/testcontainers-go/wait"
)

type TestDatabase struct {
        container testcontainers.Container
        DB        *sql.DB
        URL       string
}

func setupTestDB(t *testing.T) *sql.DB <span class="cov8" title="1">{
        t.Helper()

        ctx := context.Background()

        // Start PostgreSQL container
        postgresContainer, err := postgres.RunContainer(ctx,
                testcontainers.WithImage("postgres:15-alpine"),
                postgres.WithDatabase("movies_test"),
                postgres.WithUsername("postgres"),
                postgres.WithPassword("postgres"),
                testcontainers.WithWaitStrategy(
                        wait.ForLog("database system is ready to accept connections").
                                WithOccurrence(2).
                                WithStartupTimeout(60*time.Second),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to start postgres container: %v", err)
        }</span>

        // Clean up container when test is done
        <span class="cov8" title="1">t.Cleanup(func() </span><span class="cov8" title="1">{
                if err := postgresContainer.Terminate(ctx); err != nil </span><span class="cov0" title="0">{
                        t.Logf("Failed to terminate postgres container: %v", err)
                }</span>
        })

        // Get connection string
        <span class="cov8" title="1">connStr, err := postgresContainer.ConnectionString(ctx, "sslmode=disable")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get connection string: %v", err)
        }</span>

        // Connect to database
        <span class="cov8" title="1">db, err := sql.Open("postgres", connStr)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to connect to test database: %v", err)
        }</span>

        // Clean up database connection when test is done
        <span class="cov8" title="1">t.Cleanup(func() </span><span class="cov8" title="1">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        t.Logf("Failed to close database connection: %v", err)
                }</span>
        })

        // Wait for database to be ready
        <span class="cov8" title="1">maxRetries := 30
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov8" title="1">{
                if err := db.Ping(); err == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">if i == maxRetries-1 </span><span class="cov0" title="0">{
                        t.Fatalf("Database not ready after %d attempts", maxRetries)
                }</span>
                <span class="cov0" title="0">time.Sleep(time.Second)</span>
        }

        // Run migrations
        <span class="cov8" title="1">if err := runMigrations(db); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to run migrations: %v", err)
        }</span>

        <span class="cov8" title="1">return db</span>
}

func cleanupTestDB(t *testing.T, db *sql.DB) <span class="cov8" title="1">{
        t.Helper()

        // Delete in correct order to respect foreign key constraints
        tables := []string{
                "movie_actors",
                "actors",
                "movies",
        }

        for _, table := range tables </span><span class="cov8" title="1">{
                _, err := db.Exec(fmt.Sprintf("TRUNCATE TABLE %s RESTART IDENTITY CASCADE", table))
                if err != nil </span><span class="cov0" title="0">{
                        // Table might not exist yet, log but don't fail
                        t.Logf("Failed to truncate table %s: %v", table, err)
                }</span>
        }
}

func runMigrations(db *sql.DB) error <span class="cov8" title="1">{
        // Create tables if they don't exist
        migrations := []string{
                `CREATE TABLE IF NOT EXISTS movies (
                        id SERIAL PRIMARY KEY,
                        title VARCHAR(255) NOT NULL,
                        director VARCHAR(255) NOT NULL,
                        year INTEGER NOT NULL,
                        genre TEXT[] NOT NULL DEFAULT '{}',
                        rating DECIMAL(3,1),
                        description TEXT,
                        duration INTEGER,
                        language VARCHAR(50),
                        country VARCHAR(100),
                        poster_data BYTEA,
                        poster_type VARCHAR(50),
                        poster_url TEXT,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                )`,
                `CREATE TABLE IF NOT EXISTS actors (
                        id SERIAL PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        birth_year INTEGER NOT NULL,
                        bio TEXT,
                        image_url TEXT,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                )`,
                `CREATE TABLE IF NOT EXISTS movie_actors (
                        movie_id INTEGER NOT NULL REFERENCES movies(id) ON DELETE CASCADE,
                        actor_id INTEGER NOT NULL REFERENCES actors(id) ON DELETE CASCADE,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                        PRIMARY KEY (movie_id, actor_id)
                )`,
                `CREATE INDEX IF NOT EXISTS idx_movies_title ON movies(title)`,
                `CREATE INDEX IF NOT EXISTS idx_movies_year ON movies(year)`,
                `CREATE INDEX IF NOT EXISTS idx_actors_name ON actors(name)`,
                `CREATE INDEX IF NOT EXISTS idx_actors_birth_year ON actors(birth_year)`,
        }

        for _, migration := range migrations </span><span class="cov8" title="1">{
                if _, err := db.Exec(migration); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute migration: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SetupTestContainer creates a PostgreSQL container for integration tests
// This is useful when you need access to both the container and the database
func SetupTestContainer(t *testing.T) (*postgres.PostgresContainer, *sql.DB) <span class="cov0" title="0">{
        t.Helper()

        ctx := context.Background()

        // Get the project root to find migration files
        projectRoot := findProjectRoot()
        migrationsPath := filepath.Join(projectRoot, "tools", "migrate", "migrations")

        // Start PostgreSQL container
        postgresContainer, err := postgres.RunContainer(ctx,
                testcontainers.WithImage("postgres:15-alpine"),
                postgres.WithDatabase("movies_test"),
                postgres.WithUsername("postgres"),
                postgres.WithPassword("postgres"),
                postgres.WithInitScripts(filepath.Join(migrationsPath, "*.sql")),
                testcontainers.WithWaitStrategy(
                        wait.ForLog("database system is ready to accept connections").
                                WithOccurrence(2).
                                WithStartupTimeout(60*time.Second),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to start postgres container: %v", err)
        }</span>

        // Clean up container when test is done
        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                if err := postgresContainer.Terminate(ctx); err != nil </span><span class="cov0" title="0">{
                        t.Logf("Failed to terminate postgres container: %v", err)
                }</span>
        })

        // Get connection string
        <span class="cov0" title="0">connStr, err := postgresContainer.ConnectionString(ctx, "sslmode=disable")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to get connection string: %v", err)
        }</span>

        // Connect to database
        <span class="cov0" title="0">db, err := sql.Open("postgres", connStr)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to connect to test database: %v", err)
        }</span>

        // Clean up database connection when test is done
        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        t.Logf("Failed to close database connection: %v", err)
                }</span>
        })

        // Wait for database to be ready
        <span class="cov0" title="0">if err := waitForDatabase(db); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Database not ready: %v", err)
        }</span>

        <span class="cov0" title="0">return postgresContainer, db</span>
}

func waitForDatabase(db *sql.DB) error <span class="cov0" title="0">{
        maxRetries := 30
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                if err := db.Ping(); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">time.Sleep(time.Second)</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("database not ready after %d seconds", maxRetries)</span>
}

func findProjectRoot() string <span class="cov0" title="0">{
        // Simple heuristic: look for go.mod
        dir := "."
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                if _, err := filepath.Abs(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov0" title="0">{
                        abs, _ := filepath.Abs(dir)
                        return abs
                }</span>
                <span class="cov0" title="0">dir = filepath.Join(dir, "..")</span>
        }
        <span class="cov0" title="0">return "."</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
